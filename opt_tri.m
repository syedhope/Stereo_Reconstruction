function [x1_,x2_] = opt_tri(P1, P2, x1, x2, F,N)
%=======================================================================
% In this part of the code we implement the optimal triangulation method
% which is a direct analog of DLT as described by Richard.H and Andrew.Z 
% in 'Multiple View Geometry' in section 12.5, page 318, algorithm 12.1
% inputs --> measured point correspondence x <--> x', and the fundamental 
% matrix F. and n = no. of correspondence
% output --> that minimize the geometric error subject to the
% epipolar constraint
%=======================================================================
% transformation matrices initialization
T1 = eye(3);
T2 = eye(3);
for i=1:N
    % taking the correspondences to origin....
    T1(1:2,3) = -x1(1:2,i);
    T2(1:2,3) = -x2(1:2,i);
    % The new F corresponds to translated coordinates....
    F1 = inv(T2)'*F*inv(T1);
    % Computing the right and left epipoles...
    epi_pole1 = null(F);
    epi_pole2 = null(F');
    epi_pole1 = epi_pole1 / sqrt(epi_pole1(1)^2 + epi_pole1(2)^2);
    epi_pole2 = epi_pole2 / sqrt(epi_pole2(1)^2 + epi_pole2(2)^2);
    % computing the respective rotalional matrices...
    R1 = [epi_pole1(1:2)' 0; -epi_pole1(2) epi_pole1(1) 0; 0 0 1];
    R2 = [epi_pole2(1:2)' 0; -epi_pole2(2) epi_pole2(1) 0; 0 0 1];
    % Replacing F to have the form --> = [ff'd -f'c -f'd; -fb a b; -fd c d ]
    F1 = R2*F1*R1';
    % forming the new f matrix...
    f1 = epi_pole1(3); f2 = epi_pole2(3);
    a = F1(2,2); b = F1(2,3); c = F1(3,2); d = F1(3,3);
    % Solving for t...
    % Below are the coefficients generated by Matlab's symbolic
    % maths toolbox
    c0 = b^2*c*d-a*d^2*b;
    c1 = -a^2*d^2+b^2*c^2+f2^4*d^4+b^4+2*b^2*f2^2*d^2;
    c2 = 4*b^2*f2^2*c*d-2*a*d^2*f1^2*b+2*b^2*c*f1^2*d+...
        4*f2^4*c*d^3+4*a*b^3-a^2*d*c+b*c^2*a+4*a*b*f2^2*d^2;
    c3 = 6*a^2*b^2-2*a^2*d^2*f1^2+6*f2^4*c^2*d^2+2*b^2*f2^2*c^2+...
        2*b^2*c^2*f1^2+8*a*b*f2^2*c*d+2*a^2*f2^2*d^2;
    c4 = 4*f2^4*c^3*d-a*d^2*f1^4*b+4*a^2*f2^2*c*d+4*a*b*f2^2*c^2+...
        2*b*c^2*f1^2*a+4*a^3*b+b^2*c*f1^4*d-2*a^2*d*f1^2*c;
    c5 = (a^2+f2^2*c^2)^2-(a*d-b*c)*f1^4*b*c-(a*d-b*c)*f1^4*a*d;
    c6 = (-a*d+b*c)*f1^4*a*c;
    ts = roots([c6 c5 c4 c3 c2 c1 c0]);
    ts = real(ts);
    % Selecting the value tmin of t that gives the smallest value of the cost function.
    min_cost = Inf;
    for j = 1:length(ts)
        t = ts(j);
        cost = t^2 / (1+f1^2*t^2) + (c*t+d)^2/( (a*t+b)^2 + f2^2*(c*t+d)^2 );
        if cost < min_cost
            min_cost = cost;
            best_t = t;
        end
    end
    asym_cost = 1 / f1^2 + c^2/(a^2 + f2^2*c^2);
    if (asym_cost < min_cost)
        min_cost = asym_cost;
        best_t = inf;
    end
    % Evaluating the two lines at tmin for x1 and x2
    l1 = [best_t*f1; 1; -best_t];
    l2 = [-f2*(c*best_t+d); a*best_t+b; c*best_t+d];
    % Transfering back to the original coordinates
    x1_(:,i) = [-l1(1)*l1(3); -l1(2)*l1(3); l1(1)^2+l1(2)^2];
    x2_(:,i) = [-l2(1)*l2(3); -l2(2)*l2(3); l2(1)^2+l2(2)^2];
    x1_(:,i) = inv(T1)*R1'*x1_(:,i);
    x2_(:,i) = inv(T2)*R2'*x2_(:,i);
end
x1_ = x1_./repmat(x1_(3,:),3,1);
x2_ = x2_./repmat(x2_(3,:),3,1);
x1_ = x1_(1:2, :);
x2_ = x2_(1:2, :);
% We now need to apply the homogeneous method inorder to obtain the 3-space points
end